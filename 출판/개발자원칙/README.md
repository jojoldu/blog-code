# 제어할 수 없는 것에 의존하지 않기

소프트웨어의 원칙에 대해 이야기하라고 하면 저에게는 상당히 어려운 주제인것 같습니다.  
그래서 우선은 가벼운 이야기들을 시작으로해서 진행해보도록 하겠습니다.  
그편이 더 구체적이고 비교적 이야기가 술술 풀려나가지 않을까 생각합니다.  
  
저는 약 9년간 직업으로서의 프로그래머로 활동해왔습니다.  
경력에 비해서 이렇게 저자의 기회도 있는걸 보면 꽤나 운이 좋았던것 같습니다.    
SI, 인터넷 포털, O2O 스타트업, 에듀테크 등 여러 분야의 소프트웨어 기업들을 근무하고 팀원, 리드 등의 역할을 하다보니 고민 상담의 기회도 꽤나 많았습니다.  
  
취준생이 아닌 현직에서 일을 하시는 분들이 저에게 요청한 고민 중에서 자주 등장하는 질문이 있습니다.  

"일정을 지키고자 버그가 많은 소프트웨어를 출시하는 것이 마음에 들지 않습니다.  
어떻게 하면 일정을 연기해서 안정된 소프트웨어를 내는 것이 더 중요하다고 리더들을 설득할 수 있을까요?"  
와 같은 것입니다.  
  
이런 고민에 대해 저는 항상 윈도우 95의 프로그래머이신 "나카지마 사토시" 님의 이야기를 전달합니다.  
(아래 문장은 나카지마 사토시님의 저서인 "오늘, 또 일을 미루고 말았다" 에 나옵니다.)

"프로그래머에게 요구되는 것은 100점이 아닌 80~90점짜리 프로그램을 기한 내에 완성하는 일이다."

이렇게만 답변을 마무리 한다면, "퀄리티 보다 일정이 더 중요한 것인가" 라고 생각이 될 수도 있습니다.  
그래서 항상 덧붙여 이야기하기를, "일정과 퀄리티는 어느 한쪽을 포기해야한다와 같은 시소 관계가 아니라, **어떻게 하면 아무리 급해도 항상 80~90점의 소프트웨어를 개발할 수 있는지**가 중요하다." 라고 전달합니다.  
  
(저는 나카지마 사토시님을 실제로 뵙진 못했지만, 아마도 저와 같은 의도로 저 이야기를 하신게 아닐까하고 혼자 생각했습니다. 하하)  
  
이 답변 속에는 항상 다음 질문을 내포합니다.  
"그럼 어떻게 하면 항상 80~90점의 소프트웨어를 개발할 수 있나요?"  
  
제 주변을 보면 **급한 일정으로 일이 주어져도 항상 80~90점의 소프트웨어를 출시**하는 프로그래머분들이 있었습니다.  
옆에서 쭉 지켜보면서 그 분들의 공통점을 찾아내려고 노력했는데요.  
  
(이제부터 제가 이 책에서 이야기하고자 하는 내용이 등장할 때인것 같습니다.)   
  
그건 바로 경험과 학습으로 체득된 **본인만의 소프트웨어 원칙들**이 있었던 것입니다.  
  
예를 들어 누군가는 A 코드가 더 나을지, B 코드가 더 나을지 고민하면서 시간을 보낸다면, 그 분들은 A 코드와 B 코드 중 현재 상황에 더 적합한 코드를 판별하는 기준과 원칙들이 있어 고민 없이 바로 선택을 할 수 있었던 것이죠.  
  
대부분의 개발에서는 이렇게 기준과 원칙을 통해 빠르게 결정을 내리고 진행하면서, 정말 중요한 설계와 선택이 필요할때 더 깊게 시간을 사용합니다.  
그러다보니 당연히 항상 일정과 퀄리티 양쪽을 잡을 수 있었던것 같습니다.  
  
대니얼 J. 레비틴의 "정리하는 뇌" 에서는 머릿속이 정리 되면 크게 애쓰지 않아도 좋은 의사 결정을 할 수 있다고 이야기 합니다.  
본인만의 원칙들이 세워져 **고민거리의 숫자가 줄어들수록** 약속된 시간에 약속된 품질의 소프트웨어를 출시하기가 쉬워지는것 같습니다.  
  
이런 분들과 함께 일하다보면 자연스레 저의 소프트웨어 원칙들도 되돌아보게 됩니다.  
나는 좋은 원칙들을 알고 있는가?, 그 원칙들이 무의식적으로도 발현될 수 있도록 내재화되어있는가? 등등 말이죠.  

아마 대중적으로 가장 알려진 원칙들이라 하면 DRY, YAGNI, KISS 일것 같습니다.

* DRY
  * Do not Repeat Yourself
  * 똑같은 기능, 코드를 반복하지말라.
* YAGNI 
  * You Ain't Gonna Need It
  * 그 기능이 필요하기전까지는 미리 만들지 말라.
* KISS 
  * Keep It Simple Stupid
  * 최대한 단순함을 유지해라.

이 원칙들이 저에게 가장 중요한 원칙들일까요?  
뛰어난 주변 프로그래머들을 보면서 저 스스로도 한번 생각해보게 되었습니다. 

"나는 평소에 어떤 원칙을 가지고 소프트웨어를 개발하는가?
수많은 원칙들 중에서 내가 가장 좋아하는 원칙은 무엇인가?"

이 질문에 대답을 하자니 어떻게 대답해야할지, 상당히 망설여집니다.  
왜냐하면 소프트웨어를 만드는데 하나의 원칙만 가지고 진행하지는 않기 때문입니다.  
그간 듣고, 배운 다양한 원칙과 기준들 중에서 어느 것 하나가 최우선이 되어서 개발을 한 적이 제게는 애초에 없었고, 지금도 딱히 그러지는 않습니다.  
  
위에서 언급한 DRY, YAGNI, KISS 원칙들 역시 계속해서 적용되고 당연하게 사용하지만, 제가 가장 애정하는 원칙이라 하면 그렇지는 않습니다.  
물론 '원칙' 이라 하는 것이 대체로 시각화도, 언어화도 안되는 종류의 것이기 때문에 구체적으로 원칙들간 순위를 메길수는 없겠죠.
그래도 가장 자주 적용되는 원칙은 있지 않을까 한다면 그건 맞습니다.  

인프랩이라는 조직에 합류하고 Node.js를 처음으로 프로덕션 레벨에서 사용할때를 생각해보면, 당시의 저는 Node.js에 대한 숙련도가 낮을때임에도 불구하고 당연하게 적용하던 원칙들이 있었습니다.  
아마도 "언어, 프레임워크가 다르더라도 A, B 원칙 등은 동일하게 적용되지 않겠냐" 하는 저만의 확신이 있었던 것 같습니다.  
  
저 역시 코드와 시스템 설계에 대해 깊게 고민을 할 때 종종 떠올리는 원칙이 있는가 하면, 깊은 고민 없이 무의식적인 상태에서도 당연하게 적용되는 원칙들이 있다는 것입니다.  
  
무의식적으로 쓰는 혹은 애정하는 원칙들은 여러 가지가 있지만, 그 중에서도 제가 가장 애정하는 원칙은 "**제어할 수 없는 것에 의존하지 않기**" 입니다.  
  
저는 이 원칙을 "실용주의 프로그래머" (인사이트) 를 통해 처음 알게 되었습니다.  
실용주의 프로그래머 2장에서는 "현실 세계의 변화와 설계 사이의 결합도를 줄여야 한다. 전화번호를 식별자로 사용하고 있는가? 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라." 라는 이야기가 나옵니다.  
  
자신이 제어할 수 없는 현실 세계의 속성을 사용하는 경우는 어떤 것일까요?  
대표적인 사례로 '주민등록 번호'를 데이터베이스 테이블의 PK (Primary Key)로 사용하는 경우입니다.  
주민등록 번호는 국가에서 발행한 유일값이므로 신뢰할 수 있지 않겠냐 라고 할 수 있겠지만, 실제로 주민등록번호에는 크게 2번의 변화가 있었습니다.

* 1975년 주민등록번호 체계가 변경 되었습니다.
* 2014년 주민등록번호 무분별한 수집이 금지 되었습니다. 

![실용주의1](./images/실용주의1.png)

(2014년 안행부 가이드)  
  
2014년 주민등록번호의 무분별한 수집이 금지 되면서, 그간 주민등록번호를 주요 키로 사용하던 많은 시스템들은 모든 일정을 멈추고 주민등록 번호와의 의존성을 끊기 위해 대대적인 시스템 업데이트를 진행했습니다.  
  
절대 변하지 않을것이라 믿고 의존했던 속성이였지만, 제어할 수 없는 외부의 속성이였기에 이런 일이 발생했습니다.  
만약 해당 키 설정을 우리가 직접 만든 키 (Key)로 설정했다면, 아마도 이런 외부의 변화에 쉽게 대응할 수 있었을 것입니다.  
  
제어할 수 없는 것에 의존할수록 변화에 민감한, 흔들리기 쉬운 소프트웨어가 됩니다.  
프로그래머는 설계를 하는데 있어 외부에 의존하는 부분을 줄일수록 훨씬 더 견고한 소프트웨어를 개발할 수 있습니다.  

현실 세계의 속성과 소프트웨어간 의존관계에 대해 이야기해보았습니다.  
이 외에 제가 이 원칙을 사용한 사례들을 하나씩 살펴보겠습니다.

## 코드 설계

요즘의 소프트웨어 개발에서는 테스트 코드 작성을 중요하게 여기고 있습니다.  
하지만 개인이 가지고 있는 테스트 역량과 무관하게 테스트 코드 작성이 어려울때가 종종 있습니다.  
이는 개인의 테스트 역량 보다는 기존의 코드가 **테스트하기 좋은 코드냐 아니냐가 다르기 때문**입니다.  
  
예를 들어 다음과 같이 도메인 로직을 품고 있는 클래스가 있다고 해보겠습니다.

```ts
export default class Order {
    ...
    discount() {
        const now = LocalDateTime.now(); // 현재 시간을 반환하는 메소드
        if (now.dayOfWeek() == DayOfWeek.SUNDAY) {
            this._amount = this._amount * 0.9
        }
    }
}
```

(주문일이 일요일이면 주문 금액의 10%를 할인 하는 함수)
  
이 코드는 항상 결과를 예측하기 어려운, 즉 테스트하기 어려운 메소드입니다.
  
이유는 **실행할때마다 달라지는, 그 값을 저희가 제어할 수 없는 현재시간 생성 함수** (`LocalDateTime.now();`) 가 메소드 내부에서 사용되고 있기 때문입니다.  
  
예를 들어 이 메소드의 테스트 코드를 작성한다면 다음과 같습니다.  

```ts
it('일요일에는 주문 금액이 10% 할인된다', () => {
    const sut = Order.of(10_000, OrderStatus.APPROVAL);
    
    sut.discount();
    
    expect(sut.amount).toBe(9_000);
});
```

이 테스트는 **매주 일요일에 수행할때만 통과**할 수 있습니다.  

언제 수행하냐에 따라 테스트 대상인 `discount` 의 결과는 달라집니다.  
테스트 대상인 `discount`가 **언제나 동일한 결과를 보장하지 못하기 때문에** 테스트 코드 작성을 굉장히 어렵게 만듭니다.  
  
이 코드를 테스트 하기 위해서는 `LocalDateTime.now()` 를 Mocking 해야만 수행가능한데, 이 역시 쉽지 않습니다.
  
그렇다면 이 코드를 어떻게 개선하면 테스트하기 쉬운 코드가 될 수 있을까요?  
제어하기 어려운 코드인 현재 시간 메소드 (`LocalDateTime.now()`) 을 외부에서 주입받도록 하는 것입니다.  

```ts
export default class Order {
    ...
    // 현재시간 메소드(now)를 밖에서 주입받도록 한다.
    discountWith(now: LocalDateTimw) { 
        if (now.dayOfWeek() == DayOfWeek.SUNDAY) {
            this._amount = this._amount * 0.9
        }
    }
}
```

이렇게 할 경우 다음과 같이 제어할 수 없는 시간이라는 값을 내가 원하는 값으로 지정해서 테스트를 작성할 수 있게 됩니다.

```ts
it('일요일에는 주문 금액이 10% 할인된다', () => {
  const sut = Order.of(10_000, OrderStatus.APPROVAL);
  const now = LocalDateTime.of(2022,8,14,10,15,0); // 2022-08-14 10:15:00 시로 고정
  sut.discountWith(now);

  expect(sut.amount).toBe(9_000);
});
```

제어할 수 없는 값인 `now()` 를 메소드 인자로 빼도록 변경하는 순간 `Order.discountWith()` 메소드는 **항상 일괄된 결과를 뱉어내고, 테스트 역시 항상 일관된 결과**를 출력할 수 있게 됩니다.  
  
물론 TypeScript 와 같은 함수 인자의 기본값을 선언하는 방법을 지원하는 언어의 경우 기존의 사용성을 유지하면서 제어할 수 없는 코드에 대한 의존성을 줄일 수 있습니다.

```ts
export default class Order {
    ...
    // 인자가 없을 경우 기본값인 LocalDate.now() 를 사용
    discountWith(now = LocalDateTime.now()) { 
        if (now.dayOfWeek() == DayOfWeek.SUNDAY) {
            this._amount = this._amount * 0.9
        }
    }
}
```

정리하면 다음과 같습니다.

* 제어할 수 없는 값에 의존하는 코드들을 최대한 멀리 한다.
* 주요 비즈니스 로직들은 모두 제어할 수 있는 값만 의존하게 하여 테스트 코드 작성이 쉬운 형태로 구성한다.

메소드/함수가 제어할 수 없는 값에 의존하지 않을수록 항상 같은 결과를 반환하는 부수 효과가 적은 메소드/함수가 됩니다.  
만약 아직까지 코드를 작성할떄 제어할 수 없는 값에 의존하는 코드를 작성하고 있다면 한번 적용해보시길 바랍니다.  
그간 답답했던 많은 문제들이 해결될 것이라 생각합니다.

## 이직

이번에는 이 원칙을 소프트웨어 코드가 아닌 현실 세계에 한번 적용해보겠습니다.   

2020년 12월, 팀의 모든 시스템이 클라우드 전환이 완료되면서 저는 다음 회사로의 이직을 고민했습니다.  
이미 만 4년이 넘는 기간 동안 우아한형제들에서 근무하면서 신규 시스템 오픈, 레거시 시스템 개편, 클라우드/데이터베이스 마이그레이션 등 여러 경험들을 쌓았던 시점이라 한 회사를 졸업하기에 적절한 시기라고 생각했습니다.  
  
다음으로 어떤 조직으로 가면 좋을까 고민을 했을때, 아무래도 우아한형제들에 합류하던때가 스타트업 중 ~ 후반기였기 때문에 다음 회사는 다른 경험을 쌓고 싶었습니다.

![배민](./images/배민.png)

(우아한형제들 투자 라운드)  
  
스타트업의 전반기 (시리즈 A 이하) 경험이 부족했던 저는 이를 채워줄 수 있는 회사들을 찾아다녔습니다.  
시리즈 A 이하의 스타트업 이라 하면 정말 많은 부분이 부족합니다.

* 소수의 개발팀
* 적은 제품 성공 경험
* 부족한 복지, 보상

여러 스타트업 분들을 만나고 최종적으로 저는 당시 누적 투자 5억, 전체 개발팀이 7명이며, 인프런이라는 교육 서비스를 운영하고 있는 인프랩을 선택했습니다.  
인프랩을 선택한 이유는 여러 가지가 있습니다.  

* (고민 당시) 누적 투자 5억원의 소규모 스타트업
* 제가 좋아하는 교육/커리어 기반의 비즈니스 모델
* 제가 기존에도 사용하던 서비스

물론 이 3가지만 본다면 국내에는 수많은 스타트업들이 존재합니다.  
하지만, 인프랩은 다른 교육/커리어 서비스와 한가지 큰 차이점이 존재하며, 그 차이점이 제가 좋아하던 "제어할 수 없는 것에 의존하지 않기" 원칙과 일치했습니다.  
  
시리즈 A 이하의 소규모 스타트업에서 가장 제어할 수 없는 요소는 무엇일까요?  
시장의 크기, 오너리스크, 멤버들의 이탈 등 여러 요소가 있지만, 제가 가장 심각하게 본 요소는 바로 "투자" 입니다.  
  
수십 ~ 수백억을 투자 받아도 1년만에 소진하는 경우도 있습니다.  
추가 투자가 될 줄 알았지만, 실제로 투자가 이루어지지 않는 경우도 있습니다.  
  
아무리 회사의 좋은 이야기가 들리더라도 결국 투자사분들의 투자는 스타트업은 절대 제어할 수 없는 요소로 봤습니다.  

"투자는 투자사분들이 결정을 하는 것이고, 나와 회사는 이를 절대 제어할 수 없는데, 다음 투자를 못받으면 어떻게 될까?  
가능하면 투자를 받지 못해도 생존할 수 있는 회사여야겠다."  

당시에 저는 이 생각을 강하게 갖고 있었습니다.  

그래서 **제어할 수 없는 요소인 외부의 투자가 없어도 생존가능한 조직** 이라는 것이 저의 마지막 선택 기준이였습니다.  
이 모든 것들을 만족하는 조직은 그 당시 저에게 인프랩이 유일했습니다.  

물론 당시에는 이런 이야기를 하면 스타트업을 조금 아시는 분들은 다음과 같은 이야기를 하기도 합니다.

해당 서비스가 속해있는 시장이 얼마나 큰 시장인지,
그 회사가 시장에서 어떤 독점적 위치에 있는지,
어느 투자사의 투자를 받았는지 
등 이런 것들을 더 중요하게 봐야하는게 아니냐고 말이죠.  

위 요소들은 어떤 의미에서는 앞으로 합류할 회사가 얼마나 큰 회사가 될 수 있을지 가능성을 알아보는 기준이 될 수 있습니다.  
그리고 가능성이 큰 만큼 이후에 돌아올 제 몫도 분명히 더 클 것도 자명한 것이구요.
저 기준들을 본다면 당시의 인프랩은 분명 선택하기에는 부족한 부분이 분명 있었습니다.  
하지만, 제 입장에서는 위 요소들을 모두 만족하더라도 "제어할 수 없는 것인 투자금" 에 의존하고 있다면 제가 원하던 회사는 아닙니다.  
투자금을 통해 압도적인 성장을 하는 회사들(유니콘)도 멋지다고 생각하지만, 척박하지만 현실성 있는 성장과 재무제표를 유지하는 기업 (낙타)들을 원했습니다.
  
1년 6개월이 지난 현재와 같이 투자시장이 얼어붙을때를 당시에 미리 예상했던 것은 아닙니다.  
다만, 제어할 수 없는 것에 의존하는 부분이 적을수록 이렇게 "외부의 변화에 최대한 영향을 덜 받는다" 는 것에 저는 집중했던 것이였습니다.  
  
다행히 인프랩은 지금의 혹한기 상황에 충분히 대처가 가능해서 만족스럽게 제품과 조직 관리에만 집중할 수 있습니다.  
  
코드와 마찬가지로 현실에서도 역시 제어할 수 없는 것에 의존하기 보다는 제어할 수 있는 것에 의존할수록 쉽게 흔들리지 않는 견고한 생활을 지킬 수 있습니다.
## 조직과 매니징

이번에는 인프랩 합류 후 이야기를 해보고자 합니다.    
인프랩 합류후, 저는 한 달의 시간동안 어떤 특별한 액션을 하기보다는 기존의 팀원들이 어떻게 일을 하는지, 사내의 프로세스는 어떤것인지 지켜보기만 했습니다.  
  
퇴사전에 실장님의 조언인 "가서 바로 무언갈 하려고 하기 보다는 1~2달은 가만히 지켜만 봐라" 를 적용해보고자 한 것인데요.  
의도치 않게 이 기간 동안 저는 이 조직 내에서 "제어할 수 있는 것과 제어할 수 없는 것"을 분류 하는 기간이 되었습니다.

당시에 제가 제어할 수 없는 것들은 다음과 같습니다.

* 개발팀 전체의 연봉 테이블
* 개발팀 규모의 확장
* 기존에 같이 일해본 혹은 전직장 분들의 합류
* 기존 서비스의 기술 스택 교체

이 글을 보고 계신 분들에게는 CTO가 제어할 수 없는 부분이라는 것에 동의하기 어려우실텐데요.  
이는 인프랩이란 회사의 특수성에 기인했기 때문입니다.

* 회사가 20명이 될 때까지 한번도 시니어 레벨을 채용해본적이 없던 조직
* 시니어는 조직 전체에 큰 영향을 줄 수 있다는 것으로 인한 두려움

특히나 기존 서비스의 기술 스택을 교체한다는 것은 신뢰 관계가 전혀 없는 새로 온 CTO 가 진행하기에는 기존 구성원들의 반발심만 키울 뿐입니다.  
  
위 것들 모두 진행한다면 큰 효과를 볼 수 있지만, 당장의 제가 제어할 수는 없는 부분이라 생각되어 제가 제어할 수 있는 부분들 위주로 신뢰를 쌓기 시작했습니다.  
  
가장 먼저 진행된 것은 모니터링과 로깅 시스템 도입이였습니다.  
기존 시스템에 큰 변화를 주지 않으면서도 (제어할 수 없는 부분) 큰 효과를 볼 수 있었기 때문입니다.  

모니터링/로깅이 없다는 것은 제품의 문제 해결 그 이상의 의미가 있습니다.
바로 과거로부터 실수를 배우지 못한다는 것입니다.

* 어느 시점부터 문제가 시작 된 것일까?
* 이상 징후가 시작된 지점은 언제부터였을까?
* 우리 시스템의 트래픽 임계점은 어디까지일까?

다만, 바로 모니터링, 로깅 시스템을 도입하기 보다 현재의 우리 상황을 먼저 정리해서 확인 한 뒤에 당위성을 얻어서 진행하기로 했습니다.  
이렇게 해야 저에 대한 조직의 신뢰가 더 쌓일것이라 봤기 때문입니다.  
  
과거의 장애내역들을 정리하고 공유하면서 현재의 시스템이 얼마나 불안한 상태인지, 우리가 얼마나 놓치고 있는게 많은지 등에 공감대를 형성 했습니다.  
  
공감대가 형성 된 이후의 일은 쉽습니다.  
팀원들과 함께 빠르게 아래의 일들을 시작했습니다.

* 데이터베이스 개선 (Aurora PostgreSQL 로 마이그레이션)
* 데이터베이스 쿼리 (Query) 로깅 환경 구축 및 슬로우 쿼리 알람
    * 3초 이상 쿼리들에 대한 알람 설정과 발견된 슬로우 쿼리들 개선
* 애플리케이션 모니터링 시스템 도입 
* 필요한 알람과 불필요한 알람들을 정리

이 개선으로 서비스의 안정성과 구성원들의 신뢰를 회복할 수 있었습니다.  

다음으로 개선이 필요한 것은 구성원들의 성장이였습니다.  
당시의 인프랩은 외부의 많은 회사들이 선택한 기술, 아키텍처, 코드 컨벤션 등을 따르지 않고 독자적인 스타일을 유지하고 있었습니다.  
이를 통해서 회사가 빠르게 성장할 수 있었지만, 좀 더 큰 규모의 팀이 되기 위해서는 결국 **동시대를 살아가는 개발자들의 흐름을 놓치지 말아야 한다**는 것이 제 생각이였습니다.  
독자적인 스타일은 양날의 검처럼 갈라파고스화가 될 위험도 있기 때문입니다.  
  
이후부터 개발 팀원 전체가 동시대성을 갖추기 위한 성장을 위한 일을 진행했습니다.  
물론 이 과정에서도 제어할 수 없는 것은 존재했습니다.  
구성원 본인의 성장하고자 하는 열망은 제가 제어할 수 없는 부분입니다.  
혹자는 성장에 대한 열정도 주변에서 심어줄 수 있다고 생각하겠지만, 저는 그걸 성공해본적이 없습니다.  
  
반면 제가 제어할 수 있는 부분은 다음과 같습니다.

* 성장에 대한 열망을 가지고 있는 분을 과제와 면접을 통해 채용한다.
* 성장에 필요한 과제와 환경을 제공한다.
* 옆에서 지켜보면서 적절한 피드백을 전달한다.

이후에 채용 되는 분들은 제가 온전히 채용 과정에 합류하기 때문에 열망 있는 분을 채울 수 있지만, 이미 합류한 분들의 열망은 제가 제어할 수 없는 부분입니다.  
운이 좋게도 인프랩의 모든 개발 팀원들은 성장에 대한 열망을 가지고 있었습니다.  
그래서 저는 제가 제어할 수 있는 성장 환경에 집중했습니다.

* 채용 과정에서 실제 웹 서비스를 만드는 과제 테스트 추가
  * 제출된 과제들을 팀원들과 함께 리뷰하면서 외부의 개발자들은 어떤 구조로 / 어떤 형태로 코드를 작성하는지 자연스럽게 공유
* 앞으로 우리가 갈 길을 기존 개발자분들에게 명시하는 방향으로 채용 공고 작성
* 신규 프로젝트를 새로운 기술 스택만으로 구성
* 개발팀 전체가 함께 하는 스터디
* 주변의 좋은 시니어들과 팀원들과의 티타임, 미팅등 주선
  
이런 과정들을 통해서 인프랩 팀은 좋은 코드가 무엇인지에 서로 비슷한 공감대를 형성하고 있고, 테스트 코드를 작성하는 것이 당연해졌으며, 신규 기술 스택에 대해 안정적으로 적용하고 사용하고 있습니다.
## 마무리

현재 근무중인 인프랩에서는 최근에 개발팀 첫 퇴사자가 발생했습니다.  
**7명에서 26명이 될 때까지** 1년 4개월동안 퇴사자가 없다가 처음으로 발생한 것이죠.  
최근에 입사한 팀원들 입장에서는 처음 퇴사자를 경험한것이라 당황스러워 했을것 같습니다.  
  
물론 전혀 영향을 받지 않는 팀원들도 있었겠지만, "어? 나랑 비슷했던 저 친구도 저렇게 큰 회사를 간다고? 나도 해볼 수 있겠는데?" 같은 생각을 하는 팀원도 있을수 있습니다.  
(물론 그렇지 않기를 바래지만요.)    
  
빅테크 기업이 주는 연봉과 복지는 충분히 매력적이기 때문에 스타트업에서 빅테크로 이직을 고민하는 것은 당연히 할 수 있다고 생각합니다. 
  
다만, 주변을 보면 저희와 같이 5~20명정도 개발팀을 꾸리고 있는 스타트업에서 빅테크로 이직하는 경우가 시작될때 큰 위기를 겪게 됩니다.  
내실 있는 중~소규모의 개발팀에서 **빅테크의 사관학교**로 포지션이 변경되는 위기말이죠.  
  
조금만 삐끗하면 그 조직은 입사후 1~2년만 지나면 다 빅테크로 이직하는 조직이 되고, 입사 하는 사람도 1~2년 뒤에 빅테크를 이직하는 것을 목표로 하는 사람들만 입사하게 됩니다.  
  
그래서 이런 상황이 발생하면 CTO 분들이나 개발 리더분들이 굉장히 스트레스를 받습니다.  
결국 빅테크만큼의 연봉과 복지를 줄 수는 없는 반면 그걸 계기로 떠나는 사람들은 계속 나오기 때문입니다.  
  
물론 더 큰기업으로의 이직만이 성장을 확인할 수 있는 유일한 방법이라고 생각하지 않습니다.  
하지만 어떤 이유라도 빅테크로 한번 마음이 움직인 사람은 막을 수가 없습니다.    
  
매니징하던 팀원이 빅테크로 이직하고 나서 싱숭생순한 분위기의 팀을 리드하는 입장이라면 이 상황에서 "제어할 수 없는 것"과 "제어할 수 있는 것"은 무엇일까요?  
  
다음은 제가 퇴사가 마무리 되고 난 뒤, 개발팀 스프린트때 나눈 이야기입니다.  

"처음 발생하긴 했지만, 우리 같이 작은 조직에서 빅테크로 이직한 사람이 나왔다.  
앞으로 더 많은 사람이 퇴사하면 어떡하지 같은 걱정도 분명히 있다.  
다만, 반대로 생각해보면 이건 우리 개발조직이 가지고 있는 개발자의 성장 방법이나, 문화, 프로세스 등이 우리보다 훨씬 큰 조직에서도 인정한 사례나 마찬가지라고 생각한다.  
우리의 방식이 정말로 좋은 방식인지 의심했던 사람이 있다면, 그런 의심은 더이상 하지 않아도 된다.  
물론 1명이 이직했다고 해서 우리의 방식이 100% 좋은 방식이다라고 얘기할 순 없지만,  
지금의 방식에서 계속 개선해나간다면 어느 조직에서도 인정할만한 개발팀, 개발자가 될 수 있다고 봐도 될 것 같다.  
나는 큰 회사를 다녀놓고, 여기 있는 분들에게는 스타트업에서 일하는 것의 장점을 이야기하면 내로남불처럼 느껴질 수 있다.  
확실하게 이야기할 수 있는 것은 전 직장은 내가 입사할때까지만 하더라도 수많은 스타트업 중 하나였다.  
내가 퇴사하는 시점에 빅테크가 되어있었고, 그러다보니 빅테크의 퇴사자가 된 것 뿐이다.  
내가 폭발적으로 성장할 수 있었던 것은 스타트업이였던 조직이 빅테크로 성장하는 그 과정을 그대로 겪었기 때문이다.  
여기 계신 분들도 그 경험을 꼭 했으면 좋겠다."  

(이 내용이 실제로 팀원들에게 어떤 효과를 줬는지는 당장은 알 수가 없습니다.  
아마 미래의 인프랩 개발팀이 어떤 모습이 될지 이 글을 보고 계신 분들도 같이 봐주시는 것도 재밌는 일이 될 것 같습니다.)  
  
규모가 작은 스타트업에서의 CTO는 전체 개발자의 연봉 테이블을 제어할 수 없습니다.  
회사의 매출, 투자 규모, 다른 직군과의 연봉 격차, 회사의 연간 예산 계획등 모든 것들을 고려해야하기 때문입니다.  
만약 제가 제어할 수 없는 것에 계속 의존했다면 저는 다음과 같은 불만만 가득한 리더가 됐을 것입니다.

* 개발팀 연봉을 회사가 지원 해주지 못해서 개발팀원 퇴사를 막지 못했다.
* 연봉 테이블 전체를 못올려주면 계속 퇴사자가 나오는 것은 어쩔 수가 없다.

회사의 매출, 영업 이익등은 지금 당장 제가 제어할 수 없는 부분인데, 당장 해결이 안되는 부분을 원망해봐야 변하는 것은 없습니다.  
이 상황에서 제어할 수 있는 것은 "어떻게 하면 이 상황을 긍정적으로 해석할 수 있을까" 를 고민하고 행동으로 옮기는 것입니다.  
  
(물론 회사가 부족할때 함께 해준 팀원들에 대해 정말 감사한 마음을 갖고, 이후 여러가지 충분한 보상을 해줘야 하는 것은 당연합니다.  
이를 위해서라도 저와 대표님은 서비스와 팀원의 성장을 최대한 지원해야만 하구요.)  

최근 보고 있는 책인 "88연승의 비밀" 을 보면 다음과 같은 일화가 나옵니다.  
  
학교의 사정으로 다른 학교에서 경기를 치뤄야 하는 상황이 되었다.  
베니스 고등학교, 롱비치 시립강당, 롱비치 시립대학, 팬 퍼시픽 대강당, 산타모니카 시립대학 등을 전전했다.  
심지어 LA에서 160킬로미터나 떨어진 베이커즈필드 전문대까지 가서 홈경기를 치른 적도 있다.  
우리는 수 년 동안 홈 코트의 이점을 누릴 수 없었다.  
나는 이 불리함을 유리함으로 바꾸려고 운명이 부여한 상황에서 최선을 다했다.  
나는 선수들에게 이렇게 말했다.  
"장소를 옮겨 가면서 홈경기를 치르면 원정경기에 강해질 것이다.  
다른 곳에서 시합할 때의 산만함과 혼란스러움에 익숙할테니까."  

제어할 수 없는 것에 집중하다보면 그 무엇도 해결하지 못할 수 있습니다.  
제어할 수 있는 것에 의존하고 집중해야만 어떤 일과 상황이라도 앞으로 전진할 수 있습니다.  
  
제어할 수 있는 것과 제어할 수 없는 것을 구분한 뒤
제어할 수 없는 것은 멀리하고, 제어할 수 있는 것에 집중하면 됩니다.

외부의 요소, 이미 발생한 사건, 결정권이 없는 일 등은 제어할 수 없습니다.   
이들에 의존해선 안됩니다.  
  
제어할 수 있는 것들에만 의존하도록 해야합니다.
소프트웨어를 설계한다면 제어할 수 있는 속성에 항상 의존하게 설계해야하며,  
현실 세계의 문제라면 현재의 이 사건, 환경을 어떻게 하면 좀 더 유리하게 바라볼 수 있는지 고민하고 행동으로 옮겨야 합니다.  
  
저의 이 원칙이 여러분들께도 도움이 되었으면 합니다.
