# 제어할 수 없는 것에 의존하지 않기

소프트웨어의 원칙에 대해 이야기하라고 하면 저에게는 상당히 어려운 주제인것 같습니다.  
그래서 우선은 가벼운 이야기들을 시작으로해서 진행해보도록 하겠습니다.  
그편이 더 구체적이고 비교적 이야기가 술술 풀려나가지 않을까 생각합니다.  
  
저는 약 9년간 직업으로서의 프로그래머로 활동해왔습니다.  
경력에 비해서 이렇게 저자의 기회도 있는걸 보면 꽤나 운이 좋았던것 같습니다.    
SI, 인터넷 포털, O2O 스타트업, 에듀테크 등 여러 분야의 소프트웨어 기업들을 근무하고 팀원, 리드 등의 역할을 하다보니 고민 상담의 기회도 꽤나 많았습니다.  
  
취준생이 아닌 현직에서 일을 하시는 분들이 저에게 요청한 고민 중에서 자주 등장하는 질문이 있습니다.  

"일정을 지키고자 버그가 많은 소프트웨어를 출시하는 것이 마음에 들지 않습니다.  
어떻게 하면 일정을 연기해서 안정된 소프트웨어를 내는 것이 더 중요하다고 리더들을 설득할 수 있을까요?"  
와 같은 것입니다.  
  
이런 고민에 대해 저는 항상 윈도우 95의 프로그래머이신 "나카지마 사토시" 님의 이야기를 전달합니다.  
(아래 문장은 나카지마 사토시님의 저서인 "오늘, 또 일을 미루고 말았다" 에 나옵니다.)

"프로그래머에게 요구되는 것은 100점이 아닌 80~90점짜리 프로그램을 기한 내에 완성하는 일이다."

이렇게만 답변을 마무리 한다면, "퀄리티 보다 일정이 더 중요한 것인가" 라고 생각이 될 수도 있습니다.  
그래서 항상 덧붙여 이야기하기를, "일정과 퀄리티는 어느 한쪽을 포기해야한다와 같은 시소 관계가 아니라, **어떻게 하면 아무리 급해도 항상 80~90점의 소프트웨어를 개발할 수 있는지**가 중요하다." 라고 전달합니다.  
  
(저는 나카지마 사토시님을 실제로 뵙진 못했지만, 아마도 저와 같은 의도로 저 이야기를 하신게 아닐까하고 혼자 생각했습니다. 하하)  
  
이 답변 속에는 항상 다음 질문을 내포합니다.  
"그럼 어떻게 하면 항상 80~90점의 소프트웨어를 개발할 수 있나요?" 입니다.  
  
제 주변을 보면 **급한 일정의 일이 주어져도 항상 80~90점의 소프트웨어를 출시**하는 프로그래머분들이 있었습니다.  
옆에서 쭉 지켜보면 그 분들은 항상 공통점이 있었습니다.  
  
(이제부터 제가 이 책에서 이야기하고자 하는 내용이 등장할 때인것 같습니다.)   
  
그건 바로 경험과 학습으로 체득된 **본인만의 소프트웨어 원칙들**이 있었던 것입니다.  
  
예를 들어 누군가는 A 코드가 더 나을지, B 코드가 더 나을지 고민하면서 시간을 보낸다면, 그 분들은 A 코드와 B 코드 중 현재 상황에 더 적합한 코드를 판별하는 기준과 원칙들이 있어 고민 없이 바로 선택을 할 수 있었던 것이죠.  
  
대부분의 개발에서는 이렇게 기준과 원칙을 통해 빠르게 결정을 내리고 진행하면서, 정말 중요한 설계와 선택이 필요할때 더 깊게 시간을 사용합니다.  
그러다보니 당연히 항상 일정과 퀄리티 양쪽을 잡을 수 있었던것 같습니다.  
  
대니얼 J. 레비틴의 "정리하는 뇌" 에서는 머릿속이 정리 되면 크게 애쓰지 않아도 좋은 의사 결정을 할 수 있다고 이야기 합니다.  
본인만의 원칙들이 세워져 **고민거리의 숫자가 줄어들수록** 약속된 시간에 약속된 품질의 소프트웨어를 출시하기가 쉬워지는것 같습니다.  
  
이런 분들과 함께 일하다보면 자연스레 저의 소프트웨어 원칙들도 되돌아보게 됩니다.  
나는 좋은 원칙들을 알고 있는가?, 그 원칙들이 무의식적으로도 발현될 수 있도록 내재화되어있는가? 등등 말이죠.  

아마 대중적으로 가장 알려진 원칙들이라 하면 DRY, YAGNI, KISS 일것 같습니다.

* DRY
  * Do not Repeat Yourself
  * 똑같은 기능, 코드를 반복하지말라.
* YAGNI 
  * You Ain't Gonna Need It
  * 그 기능이 필요하기전까지는 미리 만들지 말라.
* KISS 
  * Keep It Simple Stupid
  * 최대한 단순함을 유지해라.

이 원칙들이 저에게 가장 중요한 원칙들일까요?  
뛰어난 주변 프로그래머들을 보면서 저 스스로도 한번 생각해보게 되었습니다. 

"나는 평소에 어떤 원칙을 가지고 소프트웨어를 개발하는가?
수많은 원칙들 중에서 내가 가장 좋아하는 원칙은 무엇인가?"

이 질문에 대답을 하자니 어떻게 대답해야할지, 상당히 망설여집니다.  
왜냐하면 소프트웨어를 만드는데 하나의 원칙만 가지고 진행하지는 않기 때문입니다.  
그간 듣고, 배운 다양한 원칙과 기준들 중에서 어느 것 하나가 최우선이 되어서 개발을 한 적이 제게는 애초에 없었고, 지금도 딱히 그러지는 않습니다.  
  
위에서 언급한 DRY, YAGNI, KISS 원칙들 역시 계속해서 적용되고 당연하게 사용하지만, 제가 가장 애정하는 원칙이라 하면 그렇지는 않습니다.  
물론 '원칙' 이라 하는 것이 대체로 시각화도, 언어화도 안되는 종류의 것이기 때문에 구체적으로 원칙들간 순위를 메길수는 없겠죠.
그래도 가장 자주 적용되는 원칙은 있지 않을까 한다면 그건 맞습니다.  

인프랩이라는 조직에 합류하고 Node.js를 처음으로 프로덕션 레벨에서 사용할때를 생각해보면, 당시의 저는 Node.js에 대한 숙련도가 낮을때임에도 불구하고 당연하게 적용하던 원칙들이 있었습니다.  
아마도 "언어, 프레임워크가 다르더라도 A 원칙과 B 원칙 등등은 동일하게 적용되지 않겠냐" 하는 저만의 확신이 있었던 것 같습니다.  
  
그러니깐, 저 역시 코드와 시스템 설계에 대해 깊게 고민을 할 때 종종 떠올리는 원칙이 있는가 하면, 깊은 고민 없이 무의식적인 상태에서도 당연하게 적용되는 원칙들이 있다는 것입니다.  
  
무의식적으로 쓰는 혹은 애정하는 원칙들은 여러 가지가 있지만, 그 중에서도 제가 가장 애정하는 원칙은 "제어할 수 없는 것에 의존하지 않기" 입니다.  
  
저는 이 원칙을 "실용주의 프로그래머" (인사이트) 를 통해 처음 알게 되었습니다.  
실용주의 프로그래머 2장에서는 "현실 세계의 변화와 설계 사이의 결합도를 줄여야 한다. 전화번호를 식별자로 사용하고 있는가? 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라." 라는 이야기가 나옵니다.  
  
자신이 제어할 수 없는 현실 세계의 속성을 사용하는 경우는 어떤 것일까요?  
대표적인 사례로 '주민등록 번호'를 데이터베이스 테이블의 PK (Primary Key)로 사용하는 경우입니다.  
주민등록 번호는 국가에서 발행한 유일값이므로 신뢰할 수 있지 않겠냐 라고 할 수 있겠지만, 실제로 주민등록번호에는 크게 2번의 변화가 있었습니다.

* 1975년 주민등록번호 체계가 변경 되었습니다.
* 2014년 주민등록번호 무분별한 수집이 금지 되었습니다. 

![실용주의1](./images/실용주의1.png)

(2014년 안행부 가이드)  
  
2014년 주민등록번호의 무분별한 수집이 금지 되면서, 그간 주민등록번호를 주요 키로 사용하던 많은 시스템들은 모든 일정을 멈추고 주민등록 번호와의 의존성을 끊기 위해 대대적인 업데이트를 진행했습니다.  
  
절대 변하지 않을것이라 믿고, 의존했던 외부의 유일키였지만 언제든 변할 수 있었습니다.  
만약 해당 키 설정을 우리가 직접 만든 키 (Key)로 설정했다면, 아마도 이런 외부의 변화에 쉽게 대응할 수 있었을 것입니다.  
  
즉, 제어할 수 없는 것에 의존할수록 변화에 민감한, 흔들리기 쉬운 소프트웨어가 됩니다.  
  
현실세계의 속성과 소프트웨어간 의존관계에 대해 이야기해보았습니다.  
이 외에 이 원칙을 적용할 수 있는 사례들은 무엇이 있는지 조금 더 살펴보겠습니다.

## 코드 설계

요즘의 소프트웨어 개발에서는 테스트 코드 작성을 중요하게 여기고 있습니다.  
하지만 개인이 가지고 있는 테스트 역량과 무관하게 테스트 코드 작성이 어려울때가 종종 있습니다.  
이는 개인의 테스트 역량 보다는 기존의 코드가 **테스트하기 좋은 코드냐 아니냐가 다르기 때문**입니다.  
  
예를 들어 다음과 같이 도메인 로직을 품고 있는 클래스가 있다고 해보겠습니다.

```ts
export default class Order {
    ...
    discount() {
        const now = LocalDateTime.now(); // 현재 시간을 반환하는 메소드
        if (now.dayOfWeek() == DayOfWeek.SUNDAY) {
            this._amount = this._amount * 0.9
        }
    }
}
```

(주문일이 일요일이면 주문 금액의 10%를 할인 하는 함수)
  
이 코드는 항상 결과를 예측하기 어려운, 즉 테스트하기 어려운 메소드입니다.
  
이유는 **실행할때마다 달라지는, 그 값을 저희가 제어할 수 없는 현재시간 생성 함수** (`LocalDateTime.now();`) 가 메소드 내부에서 사용되고 있기 때문입니다.  
  
예를 들어 이 메소드의 테스트 코드를 작성한다면 다음과 같습니다.  

```ts
it('일요일에는 주문 금액이 10% 할인된다', () => {
    const sut = Order.of(10_000, OrderStatus.APPROVAL);
    
    sut.discount();
    
    expect(sut.amount).toBe(9_000);
});
```

이 테스트는 **매주 일요일에 수행할때만 통과**할 수 있습니다.  

언제 수행하냐에 따라 테스트 대상인 `discount` 의 결과는 달라집니다.  
테스트 대상인 `discount`가 **언제나 동일한 결과를 보장하지 못하기 때문에** 테스트 코드 작성을 굉장히 어렵게 만듭니다.  
  
이 코드를 테스트 하기 위해서는 `LocalDateTime.now()` 를 Mocking 해야만 수행가능한데, 이 역시 쉽지 않습니다.
  
그렇다면 이 코드를 어떻게 개선하면 테스트하기 쉬운 코드가 될 수 있을까요?  
제어하기 어려운 코드인 현재 시간 메소드 (`LocalDateTime.now()`) 을 외부에서 주입받도록 하는 것입니다.  

```ts
export default class Order {
    ...
    // 현재시간 메소드(now)를 밖에서 주입받도록 한다.
    discountWith(now: LocalDateTimw) { 
        if (now.dayOfWeek() == DayOfWeek.SUNDAY) {
            this._amount = this._amount * 0.9
        }
    }
}
```

이렇게 할 경우 다음과 같이 제어할 수 없는 시간이라는 값을 내가 원하는 값으로 지정해서 테스트를 작성할 수 있게 됩니다.

```ts
it('일요일에는 주문 금액이 10% 할인된다', () => {
  const sut = Order.of(10_000, OrderStatus.APPROVAL);
  const now = LocalDateTime.of(2022,8,14,10,15,0); // 2022-08-14 10:15:00 시로 고정
  sut.discountWith(now);

  expect(sut.amount).toBe(9_000);
});
```

제어할 수 없는 값인 `now()` 를 메소드 인자로 빼도록 변경하는 순간 `Order.discountWith()` 메소드는 **항상 일괄된 결과를 뱉어내고, 테스트 역시 항상 일관된 결과**를 출력할 수 있게 됩니다.  
  
물론 TypeScript 와 같은 함수 인자의 기본값을 선언하는 방법을 지원하는 언어의 경우 기존의 사용성을 유지하면서 제어할 수 없는 코드에 대한 의존성을 줄일 수 있습니다.

**TypeScript**

```ts
// TypeScript
export default class Order {
    ...
    // 인자 호출이 없을 경우 LocalDateTime.now()를 사용
    discountWith(now = LocalDateTime.now()) { 
        if (now.dayOfWeek() == DayOfWeek.SUNDAY) {
            this._amount = this._amount * 0.9
        }
    }
}
```

제어할 수 없는 값에 의존하는 코드들에 대한 의존성을 줄일수록 메소드, 함수는 부수 효과가 적은, 매번 같은 결과가 반환될 수 있는 순수 함수에 가깝게 됩니다.  
  
즉, 제어할 수 없는 값과 메소드,함수를 분리시킬수록 해당 메소드와 함수는 부수효과 (Side Effect) 가 적은 메소드, 함수가 됩니다.

## 조직

이번에는 이 원칙을 코드가 아닌 현실 세계에도 한번 적용해보겠습니다.   

2020년 12월, 팀의 모든 시스템이 클라우드 전환이 완료되면서 저는 다음 회사로의 이직을 고민했습니다.  
이미 만 4년이 넘는 기간 동안 우아한형제들에서 근무하면서 신규 시스템 오픈, 레거시 시스템 개편, 클라우드/데이터베이스 마이그레이션 등 여러 경험들을 쌓았던 시점이라 한 회사를 졸업하기에 적절한 시기라고 생각했기 때문입니다.  
  
아무래도 제가 우아한형제들에 합류하던때가 스타트업 중반 ~ 후반기였기 때문에 다음 회사는 다른 경험을 쌓고 싶었습니다.

![배민](./images/배민.png)

(우아한형제들 투자 라운드)  
  
스타트업의 전반기 (시리즈 A 이하) 경험이 부족했던 저는 이를 채워줄 수 있는 회사들을 찾아다녔습니다.  
시리즈 A 이하의 스타트업 이라 하면 정말 많은 부분이 부족합니다.

* 소수의 개발팀
* 팀 전체적으로 부족한 제품 경험
* 

이미 수십억 ~ 수백억을 투자 받은 시리즈 A의 스타트업 분들과도 만났습니다.  
하지만 그 중에서 저는 당시 누적 투자가 5억밖에 되지 않는 인프랩 (서비스: 인프런)을 선택했습니다.  

시리즈 A 이하의 스타트업에서 가장 제어할 수 없는 요소로 저는 "투자사 (VC) 들의 투자" 라고 봤습니다.  


외부의 투자가 없어도 생존가능한 조직을 선택하자였습니다.  
수백억을 투자 받아도 1년만에 다 쓰는 경우도 기사를 통해 듣다보니 얼마를 투자 받았냐는 제가 생각하던 생존이라는 기준에서 크게 중요하지 않았던것 같습니다.

"투자는 VC들이 결정을 하는 것이고, 나는 제어할 수 없는 것인데,  
다음 투자를 못받으면 어떻게 될까?  
가능하면 투자를 받지 못해도 생존할 수 있는 회사여야겠다."
라는 기준이 적용된 것입니다. 

물론 회사를 선택하는데 있어 딱 이 한가지 원칙만 적용하진 않습니다.  
다만, 여러 조건이 다 비슷한 경우 결정을 내리는데 큰 역할을 한 것은 사실입니다.  

인프랩에 합류 후 



인프랩에 합류후 수습 해제와 동시에 저는 개발팀을 책임지는 CTO로서의 역할을 하게 됩니다.  

이 원칙을 적용하기전에 항상 준비해야할 것은 "제어할 수 있는 것과 제어할 수 없는 것을 구분하는것"이 선행되어야합니다.

퇴사전에 실장님이셨던 기호님이 해주신 조언이 있다.
가서 바로 무언갈 하려고 하기 보다는 1~2달은 가만히 지켜만 봐라 라는 것이다.

그래서 가자마자 약 한달간은 지켜보고 분석하는 시간을 가졌다.
실제로 코드리뷰도 한달은 거의 참여하지 않았다.
인프랩이 그동안 해온 코드 방향이 내가 생각한 방향과는 전혀 맞지 않았기 때문이다.
충분한 Context에 대한 이해도 없이 내가 가고자 하는 방향대로 함부로 얘기해서는 안된다고 생각했다.

이것들을 지금처럼 해서는 안된다는 것을 굉장히 우회해서 이야기를 하고, 하고 싶은 이야기를 제대로 하지 못하기도 했다.

이 과정이 사실 답답한 것도 조금은 있었다.
빠르게 성장해야하는 스타트업에서 설득하는 과정이 길어져서는 제대로 속도를 낼 수 없다는 생각이 있기 때문이다.
하지만, 그런 설득 과정이 없으면 기존 멤버들에게 상처를 주게 된다.

## 마무리

현재 근무중인 인프랩에서는 최근에 개발팀 첫 퇴사자가 발생했습니다.  
**7명에서 26명이 될 때까지** 1년 4개월동안 퇴사자가 없다가 처음으로 발생한 것이죠.  
최근에 입사한 팀원들 입장에서는 처음 퇴사자를 만나게 되는거라서 당황스러워 했습니다.  
  
물론 전혀 영향을 받지 않는 팀원들도 있었겠지만, 흔히 말하는 빅테크 기업으로 이직을 했기 때문에 혼란스러워 하는 팀원도 있었습니다.  
  
"어? 나랑 비슷했던 저 친구도 저렇게 큰 회사를 간다고? 나도 해볼 수 있겠는데?" 같은 생각을 했을수도 있습니다.  
(물론 그렇지 않기를 바래지만요.)    
  
빅테크 기업이 주는 연봉과 복지는 충분히 매력적이기 때문에 스타트업에서 빅테크로 이직을 고민하는 것은 당연히 할 수 있다고 생각합니다. 
주변을 보면 저희와 같이 5~20명정도 개발팀을 꾸리고 있는 스타트업에서 빅테크로 이직하는 경우가 시작될때 큰 위기를 겪게 됩니다.  
내실 있는 중~소규모의 개발팀에서 **빅테크의 사관학교**로 포지션이 변경되는 위기말이죠.  
  
조금만 삐끗하면 그 조직은 입사후 1~2년만 지나면 다 빅테크로 이직하는 조직이 되고, 입사 하는 사람도 1~2년 뒤에 빅테크를 이직하는 것을 목표로 하는 사람들만 입사하게 됩니다.  
  
그래서 이런 상황이 발생하면 CTO 분들이나 개발 리더분들이 굉장히 스트레스를 받습니다.  
결국 빅테크만큼의 연봉과 복지를 줄 수는 없는 반면 그걸 계기로 떠나는 사람들은 계속 나오기 때문입니다.  
  
물론 더 큰기업으로의 이직만이 성장을 확인할 수 있는 유일한 방법이라고 생각하지 않습니다.  
하지만 어떤 이유라도 빅테크로 한번 마음이 움직인 사람은 막을 수가 없습니다.    
  
매니징하던 팀원이 빅테크로 이직하고 나서 싱숭생순한 분위기의 팀을 리드하는 입장이라면 이 상황에서 "제어할 수 없는 것"과 "제어할 수 있는 것"은 무엇일까요?  
  
다음은 제가 퇴사가 마무리 되고 난 뒤, 개발팀 스프린트때 나눈 이야기입니다.  

"처음 발생하긴 했지만, 우리 같이 작은 조직에서 빅테크로 이직한 사람이 나왔다.  
앞으로 더 많은 사람이 퇴사하면 어떡하지 같은 걱정도 분명히 있다.  
다만, 반대로 생각해보면 이건 우리 개발조직이 가지고 있는 개발자의 성장 방법이나, 문화, 프로세스 등이 우리보다 훨씬 큰 조직에서도 인정한 사례나 마찬가지라고 생각한다.  
우리의 방식이 정말로 좋은 방식인지 의심했던 사람이 있다면, 그런 의심은 더이상 하지 않아도 된다.  
물론 1명이 이직했다고 해서 우리의 방식이 100% 좋은 방식이다라고 얘기할 순 없지만,  
지금의 방식에서 계속 개선해나간다면 어느 조직에서도 인정할만한 개발팀, 개발자가 될 수 있다고 봐도 될 것 같다.  
  
나는 큰 회사를 다녀놓고, 여기 있는 분들에게는 스타트업에서 일하는 것의 장점을 이야기하면 내로남불처럼 느껴질 수 있다.  
확실하게 이야기할 수 있는 것은 전 직장은 내가 입사할때까지만 하더라도 수많은 스타트업 중 하나였다.  
내가 퇴사하는 시점에 빅테크가 되어있었고, 그러다보니 빅테크의 퇴사자가 된 것 뿐이다.  
내가 폭발적으로 성장할 수 있었던 것은 스타트업이였던 조직이 빅테크로 성장하는 그 과정을 그대로 겪었기 때문이다.  
여기 계신 분들도 그 경험을 꼭 했으면 좋겠다."  

규모가 작은 스타트업에서의 CTO는 전체 개발자의 연봉 테이블을 제어할 수 없습니다.  
그건 회사의 매출, 투자 규모, 다른 직군과의 연봉 격차, 회사의 연간 예산 계획등 모든 것들을 고려해야하기 때문입니다.  
만약 제가 제어할 수 없는 것에 게속 의존했다면 저는 다음과 같은 불만만 가득한 리더가 됩니다.

* 개발팀 연봉을 회사가 지원 해주지 못해서 개발팀원 퇴사를 막지 못했다.
* 연봉 테이블 전체를 못올려주면 계속 퇴사자가 나오는 것은 어쩔 수가 없다.

하지만 회사의 매출, 영업 이익등은 지금 당장 제가 제어할 수 없는 부분인데, 당장 해결이 안되는 부분을 원망해봐야 변하는 것은 없습니다.  
이 상황에서 제어할 수 있는 것은 "어떻게 하면 이 상황을 긍정적으로 해석할 수 있을까" 를 고민하고 행동으로 옮기는 것입니다.  
  
(물론 회사가 부족할때 함께 해준 팀원들에 대해 정말 감사한 마음을 갖고, 이후 여러가지 충분한 보상을 해줘야 하는 것은 당연합니다.  
이를 위해서라도 저와 대표님은 서비스와 팀원의 성장을 최대한 지원해야만 하구요.)  

최근 보고 있는 책인 88연승의 비밀을 보면 다음과 같은 일화가 나옵니다.  
  
학교의 사정으로 다른 학교에서 경기를 치뤄야 하는 상황이 되었다.  
베니스 고등학교, 롱비치 시립강당, 롱비치 시립대학, 팬 퍼시픽 대강당, 산타모니카 시립대학 등을 전전했다.  
심지어 LA에서 160킬로미터나 떨어진 베이커즈필드 전문대까지 가서 홈경기를 치른 적도 있다.  
우리는 수 년 동안 홈 코트의 이점을 누릴 수 없었다.  
나는 이 불리함을 유리함으로 바꾸려고 운명이 부여한 상황에서 최선을 다했다.  
나는 선수들에게 이렇게 말했다.  
"장소를 옮겨 가면서 홈경기를 치르면 원정경기에 강해질 것이다.  
다른 곳에서 시합할 때의 산만함과 혼란스러움에 익숙할테니까."  


제어할 수 없는 것에 의존하지 않기 원칙은 다른 말로 하면 "제어할 수 있는 것에 집중하기" 입니다.  

* 제어할 수 있는 것과 제어할 수 없는 것을 구분한 뒤
* 제어할 수 없는 것은 멀리하고, 제어할 수 있는 것에 집중한다.

바뀔 수 없는 것에 몰두하지 말자.  
이미 발생한 사건, 이미 처해진 환경은 내가 어떻게 할 수가 없다.  
내가 할 수 있는 건 현재의 이 사건, 환경을 어떻게 하면 좀 더 유리하게 바라볼 수 있는지 고민하고 행동으로 옮기는 것이다.  
내가 가지고 있는 무기로 싸우는 것에 익숙해져야 한다.
